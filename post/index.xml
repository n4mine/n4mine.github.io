<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on n4mine&#39;s blog</title>
    <link>https://n4mine.github.io/post/</link>
    <description>Recent content in Posts on n4mine&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 05 Dec 2018 14:43:45 +0800</lastBuildDate>
    
	<atom:link href="https://n4mine.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>监控系统构建实践之传输篇</title>
      <link>https://n4mine.github.io/post/the-practice-of-buiding-monitoring-system-transfer/</link>
      <pubDate>Wed, 05 Dec 2018 14:43:45 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/the-practice-of-buiding-monitoring-system-transfer/</guid>
      <description>&lt;p&gt;在上一篇文章采集篇的事情做完后，源数据就已经有了，但应该如何上报到存储就是接下来要考虑到的事情。&lt;br /&gt;
本文结合我司在传输链路的建设，简述一下期间的一点思考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>计算进程的CPU占用率</title>
      <link>https://n4mine.github.io/post/calculate-the-cpu-usage-of-a-process/</link>
      <pubDate>Tue, 03 Jul 2018 11:28:34 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/calculate-the-cpu-usage-of-a-process/</guid>
      <description>&lt;h2 id=&#34;基于-proc-pid-stat和-proc-stat计算指定进程的cpu利用率&#34;&gt;基于/proc/[pid]/stat和/proc/stat计算指定进程的cpu利用率&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh

corenum=$(nproc --all)
p=xxx
pid=$(pidof $p)
p_totaltime1=$(awk &#39;{print $14+$15}&#39; /proc/${pid}/stat)
totaltime1=$(awk &#39;{if($1==&amp;quot;cpu&amp;quot;){for(i=2;i&amp;lt;=NF;i++){sum+=$i}}}END{print sum}&#39; /proc/stat)
sleep 3 # 为什么是3, 要得到与top相同的结果
p_totaltime2=$(awk &#39;{print $14+$15}&#39; /proc/${pid}/stat)
totaltime2=$(awk &#39;{if($1==&amp;quot;cpu&amp;quot;){for(i=2;i&amp;lt;=NF;i++){sum+=$i}}}END{print sum}&#39; /proc/stat)

res=$(awk &#39;BEGIN{print &#39;&amp;quot;($p_totaltime2-$p_totaltime1)*100/($totaltime2-$totaltime1)*$corenum&amp;quot;&#39;}&#39;)

echo $res
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>监控系统构建实践-采集篇</title>
      <link>https://n4mine.github.io/post/the-practice-of-buiding-monitoring-system-collector/</link>
      <pubDate>Mon, 30 Apr 2018 17:12:45 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/the-practice-of-buiding-monitoring-system-collector/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;监控系统这个话题很大。&lt;br /&gt;
但一个基本的监控系统归纳起来，无非也就是数据采集、传输、存储、查询这么几个部分。&lt;br /&gt;
本文尝试从宏观上分析这几个模块在实践上遇到的一些问题，在我司的&lt;del&gt;最佳实践&lt;/del&gt;解法，及本人对各个模块在实践中的一些思考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Open-Falcon更换hash算法</title>
      <link>https://n4mine.github.io/post/open-falcon-change-hash-algorithm/</link>
      <pubDate>Sat, 10 Mar 2018 17:06:29 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/open-falcon-change-hash-algorithm/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;原生的open-falcon使用一致性哈希来进行存储的分片。其使用到的一致性哈希算法库是&lt;a href=&#34;https://github.com/stathat/consistent&#34;&gt;github.com/stathat/consistent&lt;/a&gt;&lt;br /&gt;
这个库使用了CRC32作为hash算法。CRC32用于一致性哈希时，结果是非常不均匀的。&lt;br /&gt;
而且open-falcon只使用500个虚拟节点，统计进到graph的点数速度，标准差结果甚至到了15k+。&lt;br /&gt;
更换hash算法成为当务之急。&lt;/p&gt;

&lt;p&gt;我们将&lt;code&gt;CRC32 + 500虚拟节点&lt;/code&gt;，变成了&lt;code&gt;murmur3 + 10000虚拟节点&lt;/code&gt;, 看官可能觉得在跑着业务的系统上，难度很高，而实际上整个过程简单的一逼&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用sync.Pool引起的case一例</title>
      <link>https://n4mine.github.io/post/a-case-when-using-sync.pool/</link>
      <pubDate>Tue, 27 Feb 2018 15:12:20 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/a-case-when-using-sync.pool/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;open-falcon的graph模块占用内存太多, 即发起了graph的内存优化，在上线过程中发生了曲线值异常的问题&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过pprof获取golang gc信息</title>
      <link>https://n4mine.github.io/post/get-golang-gc-info-by-pprof/</link>
      <pubDate>Sat, 04 Nov 2017 10:23:25 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/get-golang-gc-info-by-pprof/</guid>
      <description>背景 服务在开启了pprof的情况下，可以使用如下方式，简单粗暴的的获取gc情况 实现 #!/bin/bash _lastNumGC=0 _first=true while : ; do r=$(curl -s 127.0.0.1:6071/debug/pprof/heap?debug=1 | tail -22) _NumGC=$(echo $r | sed &#39;s/#/\n#/g&#39; | grep &amp;quot;^# NumGC&amp;quot; | awk &#39;{print $NF}&#39;) NumGC=$[ ${_NumGC} -</description>
    </item>
    
    <item>
      <title>使用iterm2的coprocess完成自动登录</title>
      <link>https://n4mine.github.io/post/autologin-with-iterm2-coprocess/</link>
      <pubDate>Mon, 25 Sep 2017 18:10:41 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/autologin-with-iterm2-coprocess/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;日常工作中，经常需要通过跳板机登录线上机器。&lt;br /&gt;
而为了安全起见，系统部的同学又启用了otp，动态生成code&lt;br /&gt;
给经常登录线上机器的使用者，带来了很大不便&lt;/p&gt;

&lt;p&gt;作为iterm2的使用者，其coprocess的功能，可以实现自动登录，极大减少了手工输入动态密码及个人密码的次数。&lt;br /&gt;
什么是iterm2的coprocess，可参见其官方说明 &lt;a href=&#34;https://www.iterm2.com/documentation-coprocesses.html&#34;&gt;coprocesses&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>organizing golang projects and dependencies</title>
      <link>https://n4mine.github.io/post/organizing-golang-projects-and-dependencies/</link>
      <pubDate>Sun, 15 Jan 2017 14:49:18 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/organizing-golang-projects-and-dependencies/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;golang的依赖一直是让人头疼的问题, 大家对其自有的package管理也是褒贬不一&lt;br /&gt;
而对于一个公司内部项目来讲, 主要的需求有以下几点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;方便的依赖包版本管理&lt;/li&gt;
&lt;li&gt;方便协同开发&lt;/li&gt;
&lt;li&gt;尽可能不依赖其编译所在环境&lt;/li&gt;
&lt;li&gt;除基础包之外, 第三方包尽可能的自包含&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于此, 有了本文, 打算以最小的环境变更及工具, 打造一个可协同工作的golang projects&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>调用服务端随机性连接超时case一例</title>
      <link>https://n4mine.github.io/post/random-connection-timeout/</link>
      <pubDate>Wed, 05 Oct 2016 09:47:13 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/random-connection-timeout/</guid>
      <description>&lt;h1 id=&#34;现象&#34;&gt;现象&lt;/h1&gt;

&lt;p&gt;业务同学反馈，A服务调用B服务有连接超时&lt;/p&gt;

&lt;h1 id=&#34;环境&#34;&gt;环境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;src：A服务, 以下均用src代指&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dst：B服务, 以下均用dst代指&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;B服务通过lvs + nginx的方式对外服务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;A服务连接超时设置为500ms&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>动态监控磁盘分区使用ETA</title>
      <link>https://n4mine.github.io/post/fs-size-eta/</link>
      <pubDate>Fri, 22 Jan 2016 12:43:29 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/fs-size-eta/</guid>
      <description>&lt;h2 id=&#34;名词解释&#34;&gt;名词解释&lt;/h2&gt;

&lt;p&gt;eta，是estimated time of arrival的缩写，通常指灰机、轮船等的预计到达时间。&lt;br /&gt;
拿到运维系统中，含义即为某个分区预计还有多长时间被打满。（暂定为此名字，还没想到其他贴切的词）&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;为什么搞这个监控，我们不是有现成的剩余空间监控（vfs.fs.size[/,free]和剩余空间百分比监控（vfs.fs.size[/,pfree]）么？&lt;br /&gt;
原因在于，上述两项监控，都是死的，例如我们设置某个分区剩余空间百分比小于10%时报警，那么在该分区剩余空间百分比大于10%时，我们不会收到任何报警。&lt;br /&gt;
而这种情况，不能基于磁盘最近的增长量来判断磁盘打满的eta。&lt;br /&gt;
数学上有很多求平均数的方法&lt;sup&gt;[1]&lt;/sup&gt;，此处磁盘eta的算法更倾向于使用指数平均法，即“各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重”，但我们只取最近N个值的平均数，直接砍掉N之前的历史数。所以只是形式上相像而已。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2015</title>
      <link>https://n4mine.github.io/post/2015/</link>
      <pubDate>Thu, 31 Dec 2015 22:43:29 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/2015/</guid>
      <description>&lt;p&gt;又是一年终了时，又吸了一年的京霾，又老了一岁。&lt;br /&gt;
年龄愈长，越觉时间过得快。&lt;br /&gt;
毕业那刻，仿佛还在昨天，不过是梦一场，6年多的时间过去了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个普通sre一天的工作记录</title>
      <link>https://n4mine.github.io/post/sre-diary/</link>
      <pubDate>Thu, 05 Mar 2015 20:49:00 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/sre-diary/</guid>
      <description>&lt;p&gt;本文记录一个sre一天的工作&lt;br /&gt;
背景交代：80后、单身&lt;br /&gt;
职位：sre&lt;br /&gt;
公司：规模不小但sre团队组建不久&lt;/p&gt;

&lt;p&gt;以下是正文&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>lua判断是否是私有IP地址</title>
      <link>https://n4mine.github.io/post/private-ip-or-not/</link>
      <pubDate>Tue, 03 Feb 2015 08:24:00 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/private-ip-or-not/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ngx_lua模块，判断nginx的$remote_addr取到之后是否属于私有IP&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>监控进程卡住导致内存耗尽</title>
      <link>https://n4mine.github.io/post/run-out-of-memory/</link>
      <pubDate>Fri, 02 Jan 2015 10:22:31 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/run-out-of-memory/</guid>
      <description>&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;

&lt;p&gt;大早上收到报警，几台机器内存不足&lt;br /&gt;
想上去查原因，已登录不上&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx通过geo实现production/preview环境分离，限速/非限速IP分离</title>
      <link>https://n4mine.github.io/post/nginx_geo/</link>
      <pubDate>Thu, 13 Nov 2014 20:14:06 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/nginx_geo/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;根据来源IP区分production/preview环境&lt;/li&gt;
&lt;li&gt;根据来源IP区分限速/非限速&lt;/li&gt;
&lt;li&gt;结合上面两者&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;geo, map&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>nginx使用if实现多重判断case一例</title>
      <link>https://n4mine.github.io/post/if_in_nginx/</link>
      <pubDate>Thu, 13 Nov 2014 17:53:55 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/if_in_nginx/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;根据请求URI的某个参数，判断后分发到不同backend。具体来说会判断是否存在code=OVERSEA&amp;hellip;，有则upstream到指定backend&lt;/li&gt;
&lt;li&gt;根据来源IP区分production环境和preview环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;上面提到的参数可能重复出现&lt;/li&gt;
&lt;li&gt;if不支持复杂的逻辑运算&lt;/li&gt;
&lt;li&gt;if is evil&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>nginx根据后端返回状态进行upstream</title>
      <link>https://n4mine.github.io/post/nginx_route_by_upstream_status/</link>
      <pubDate>Tue, 11 Nov 2014 11:08:42 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/nginx_route_by_upstream_status/</guid>
      <description>&lt;h1 id=&#34;需求&#34;&gt;需求&lt;/h1&gt;

&lt;p&gt;某系统，需在国外建立完全独立的一套业务。且国内已有用户还需继续维护。&lt;br /&gt;
由于带宽、响应时间等原因，通过db主从的方式全球同步数据存在一系列问题。&lt;/p&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;放在前端的nginx不能判断用户归属国家，判断逻辑太重，nginx不适合做这个&lt;/li&gt;
&lt;li&gt;nginx后端的backend有自己的逻辑判断用户归属，用返回的status code来标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;nginx + lua + subrequest&lt;/li&gt;
&lt;li&gt;要在content阶段完成&lt;/li&gt;
&lt;li&gt;需在rewrite阶段做一点处理&lt;/li&gt;
&lt;li&gt;GET和POST要区分对待&lt;/li&gt;
&lt;li&gt;POST的body和GET的args、cookie等处理&lt;/li&gt;
&lt;li&gt;nginx根据后端的不同返回status code，进行逻辑判断，是直接返回给client还是重新proxy到其他国家&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>ansible安装JDK</title>
      <link>https://n4mine.github.io/post/ansible_install_jdk/</link>
      <pubDate>Sat, 18 Oct 2014 20:53:49 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/ansible_install_jdk/</guid>
      <description>&lt;p&gt;JDK这东西，简单来说就是一个包，主要生效的还是环境变量。&lt;br /&gt;
直接上实现&lt;/p&gt;

&lt;h2 id=&#34;目录结构&#34;&gt;目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── files
│   └── jdk1.6-centos6.tar.gz
└── main.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的一个说明而已，没有必要搞什么最佳实践了。^_^&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开篇流水</title>
      <link>https://n4mine.github.io/post/first/</link>
      <pubDate>Thu, 24 Jul 2014 23:02:08 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/first/</guid>
      <description>&lt;h2 id=&#34;始&#34;&gt;始&lt;/h2&gt;

&lt;p&gt;其实一、两年前就打算搞个blog，但一直&lt;del&gt;忙&lt;/del&gt;懒，所以断断续续的，最后也没完成。&lt;br /&gt;
但愿这个能坚持下去！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>