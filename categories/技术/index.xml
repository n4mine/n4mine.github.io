<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on n4mine&#39;s blog</title>
    <link>https://n4mine.github.io/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on n4mine&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 27 Feb 2018 15:12:20 +0800</lastBuildDate>
    
	<atom:link href="https://n4mine.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用sync.Pool引起的case一例</title>
      <link>https://n4mine.github.io/post/a-case-when-using-sync.pool/</link>
      <pubDate>Tue, 27 Feb 2018 15:12:20 +0800</pubDate>
      
      <guid>https://n4mine.github.io/post/a-case-when-using-sync.pool/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;open-falcon的graph模块占用内存太多, 即发起了graph的内存优化，在上线过程中发生了曲线值异常的问题&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过pprof获取golang gc信息</title>
      <link>https://n4mine.github.io/post/get-golang-gc-info-by-pprof/</link>
      <pubDate>Sat, 04 Nov 2017 10:23:25 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/get-golang-gc-info-by-pprof/</guid>
      <description>背景 服务在开启了pprof的情况下，可以使用如下方式，简单粗暴的的获取gc情况 实现 #!/bin/bash _lastNumGC=0 _first=true while : ; do r=$(curl -s 127.0.0.1:6071/debug/pprof/heap?debug=1 | tail -22) _NumGC=$(echo $r | sed &#39;s/#/\n#/g&#39; | grep &amp;quot;^# NumGC&amp;quot; | awk &#39;{print $NF}&#39;) NumGC=$[ ${_NumGC} -</description>
    </item>
    
    <item>
      <title>使用iterm2的coprocess完成自动登录</title>
      <link>https://n4mine.github.io/post/autologin-with-iterm2-coprocess/</link>
      <pubDate>Mon, 25 Sep 2017 18:10:41 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/autologin-with-iterm2-coprocess/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;日常工作中，经常需要通过跳板机登录线上机器。&lt;br /&gt;
而为了安全起见，系统部的同学又启用了otp，动态生成code&lt;br /&gt;
给经常登录线上机器的使用者，带来了很大不便&lt;/p&gt;

&lt;p&gt;作为iterm2的使用者，其coprocess的功能，可以实现自动登录，极大减少了手工输入动态密码及个人密码的次数。&lt;br /&gt;
什么是iterm2的coprocess，可参见其官方说明 &lt;a href=&#34;https://www.iterm2.com/documentation-coprocesses.html&#34;&gt;coprocesses&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>聊聊监控系统(02) 数据的采集</title>
      <link>https://n4mine.github.io/post/monitor-system-02-data-collect/</link>
      <pubDate>Thu, 21 Sep 2017 07:36:03 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/monitor-system-02-data-collect/</guid>
      <description>&lt;h2 id=&#34;数据采集&#34;&gt;数据采集&lt;/h2&gt;

&lt;p&gt;先来聊数据的源头，看官可能觉得不就是个agent么，搞好cpu、mem等基础指标的采集，上报上来不就好了，其实不然&lt;br /&gt;
首先，作为agent，一个最大的特点就是离中心太远了，远到无法很好的控制它。&lt;br /&gt;
尤其前期，不断的更新、迭代、修bug，当你有几十几百台机器时，都不是问题，什么ssh、ansible分分钟就搞定了。&lt;br /&gt;
但当你的规模成千上万的时候，就会发现，版本迭代是在是太痛苦了。&lt;br /&gt;
而且数量不是唯一的问题，例如你的上报中心地址变了，有网络分区了，有各种各样恶心的场景。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>聊聊监控系统(01) overview</title>
      <link>https://n4mine.github.io/post/monitor-system-01-overview/</link>
      <pubDate>Sat, 15 Jul 2017 07:36:03 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/monitor-system-01-overview/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;监控这个话题太大了，本文谨记录本人在参与我司监控系统重构开发过程中的一些思考。&lt;br /&gt;
包括技术上、产品形态上的一些内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>organizing golang projects and dependencies</title>
      <link>https://n4mine.github.io/post/organizing-golang-projects-and-dependencies/</link>
      <pubDate>Sun, 15 Jan 2017 14:49:18 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/organizing-golang-projects-and-dependencies/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;golang的依赖一直是让人头疼的问题, 大家对其自有的package管理也是褒贬不一&lt;br /&gt;
而对于一个公司内部项目来讲, 主要的需求有以下几点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;方便的依赖包版本管理&lt;/li&gt;
&lt;li&gt;方便协同开发&lt;/li&gt;
&lt;li&gt;尽可能不依赖其编译所在环境&lt;/li&gt;
&lt;li&gt;除基础包之外, 第三方包尽可能的自包含&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于此, 有了本文, 打算以最小的环境变更及工具, 打造一个可协同工作的golang projects&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>调用服务端随机性连接超时case一例</title>
      <link>https://n4mine.github.io/post/random-connection-timeout/</link>
      <pubDate>Wed, 05 Oct 2016 09:47:13 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/random-connection-timeout/</guid>
      <description>&lt;h1 id=&#34;现象&#34;&gt;现象&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>动态监控磁盘分区使用ETA</title>
      <link>https://n4mine.github.io/post/fs-size-eta/</link>
      <pubDate>Fri, 22 Jan 2016 12:43:29 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/fs-size-eta/</guid>
      <description>&lt;h2 id=&#34;名词解释&#34;&gt;名词解释&lt;/h2&gt;

&lt;p&gt;eta，是estimated time of arrival的缩写，通常指灰机、轮船等的预计到达时间。&lt;br /&gt;
拿到运维系统中，含义即为某个分区预计还有多长时间被打满。（暂定为此名字，还没想到其他贴切的词）&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;为什么搞这个监控，我们不是有现成的剩余空间监控（vfs.fs.size[/,free]和剩余空间百分比监控（vfs.fs.size[/,pfree]）么？&lt;br /&gt;
原因在于，上述两项监控，都是死的，例如我们设置某个分区剩余空间百分比小于10%时报警，那么在该分区剩余空间百分比大于10%时，我们不会收到任何报警。&lt;br /&gt;
而这种情况，不能基于磁盘最近的增长量来判断磁盘打满的eta。&lt;br /&gt;
数学上有很多求平均数的方法&lt;sup&gt;[1]&lt;/sup&gt;，此处磁盘eta的算法更倾向于使用指数平均法，即“各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重”，但我们只取最近N个值的平均数，直接砍掉N之前的历史数。所以只是形式上相像而已。&lt;br /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>lua判断是否是私有IP地址</title>
      <link>https://n4mine.github.io/post/private-ip-or-not/</link>
      <pubDate>Tue, 03 Feb 2015 08:24:00 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/private-ip-or-not/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ngx_lua模块，判断nginx的$remote_addr取到之后是否属于私有IP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>监控进程卡住导致内存耗尽</title>
      <link>https://n4mine.github.io/post/run-out-of-memory/</link>
      <pubDate>Fri, 02 Jan 2015 10:22:31 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/run-out-of-memory/</guid>
      <description>&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;

&lt;p&gt;大早上收到报警，几台机器内存不足&lt;br /&gt;
想上去查原因，已登录不上&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx通过geo实现production/preview环境分离，限速/非限速IP分离</title>
      <link>https://n4mine.github.io/post/nginx_geo/</link>
      <pubDate>Thu, 13 Nov 2014 20:14:06 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/nginx_geo/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;根据来源IP区分production/preview环境&lt;/li&gt;
&lt;li&gt;根据来源IP区分限速/非限速&lt;/li&gt;
&lt;li&gt;结合上面两者&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;geo, map&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx使用if实现多重判断case一例</title>
      <link>https://n4mine.github.io/post/if_in_nginx/</link>
      <pubDate>Thu, 13 Nov 2014 17:53:55 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/if_in_nginx/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;根据请求URI的某个参数，判断后分发到不同backend。具体来说会判断是否存在code=OVERSEA&amp;hellip;，有则upstream到指定backend&lt;/li&gt;
&lt;li&gt;根据来源IP区分production环境和preview环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;上面提到的参数可能重复出现&lt;/li&gt;
&lt;li&gt;if不支持复杂的逻辑运算&lt;/li&gt;
&lt;li&gt;if is evil&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx根据后端返回状态进行upstream</title>
      <link>https://n4mine.github.io/post/nginx_route_by_upstream_status/</link>
      <pubDate>Tue, 11 Nov 2014 11:08:42 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/nginx_route_by_upstream_status/</guid>
      <description>&lt;h1 id=&#34;需求&#34;&gt;需求&lt;/h1&gt;

&lt;p&gt;某系统，需在国外建立完全独立的一套业务。且国内已有用户还需继续维护。&lt;br /&gt;
由于带宽、响应时间等原因，通过db主从的方式全球同步数据存在一系列问题。&lt;/p&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;放在前端的nginx不能判断用户归属国家，判断逻辑太重，nginx不适合做这个&lt;/li&gt;
&lt;li&gt;nginx后端的backend有自己的逻辑判断用户归属，用返回的status code来标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;nginx + lua + subrequest&lt;/li&gt;
&lt;li&gt;要在content阶段完成&lt;/li&gt;
&lt;li&gt;需在rewrite阶段做一点处理&lt;/li&gt;
&lt;li&gt;GET和POST要区分对待&lt;/li&gt;
&lt;li&gt;POST的body和GET的args、cookie等处理&lt;/li&gt;
&lt;li&gt;nginx根据后端的不同返回status code，进行逻辑判断，是直接返回给client还是重新proxy到其他国家&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ansible安装JDK</title>
      <link>https://n4mine.github.io/post/ansible_install_jdk/</link>
      <pubDate>Sat, 18 Oct 2014 20:53:49 +0000</pubDate>
      
      <guid>https://n4mine.github.io/post/ansible_install_jdk/</guid>
      <description>&lt;p&gt;JDK这东西，简单来说就是一个包，主要生效的还是环境变量。&lt;br /&gt;
直接上实现&lt;/p&gt;

&lt;h2 id=&#34;目录结构&#34;&gt;目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
├── files
│   └── jdk1.6-centos6.tar.gz
└── main.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的一个说明而已，没有必要搞什么最佳实践了。^_^&lt;br /&gt;
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>